<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>
		<meta charset="utf-8">
		<title>Tanks Game</title>
	</head>
	<body>
		<script src="https://koda.nu/simple.js">
			// Spåren som pansarvagnarna lämnar efter sig. Pansarvagnarna skapar hela tiden nya instances av denna class
			// och lägger in dem i trails variablen. I update kallas update för varje trail-objekt.
			class Trail {
				constructor(x, y, angle, size) {
					this.x = x;
					this.y = y;
					this.angle = angle;
					this.size = size;
				}

				update() {
					this.draw();
				}

				draw() {
					save();
					translate(this.x, this.y);
					rotateRadians(this.angle);
					let s = this.size/2.5;
					cRectangle(0, s, this.size/7, s, "rgba(0, 0, 0, 0.3)");
					cRectangle(0, -s, this.size/7, s, "rgba(0, 0, 0, 0.3)");
					restore();
				}
			}

			// Varje gång en pansarvagn, en mina eller ett skott exploderar skapas ett explosion-objekt som snabbt
			// tar bort sig själv efter att effekten är färdig.
			class Explosion {
				constructor(x, y, radius, destroyTiles=true, kills=true, time=20) {
					this.x = x;
					this.y = y;
					this.radius = radius;
					this.time = time;
					this.destroyTiles = destroyTiles;
					this.hasDestroyedTiles = false;
					this.kills = kills;
					this.hasKilled = false;
					smallExplosion.pause();
					smallExplosion.currentTime = 0.8;
					smallExplosion.play();
				}

				update() {
					this.draw();

					if(this.destroyTiles && !this.hasDestroyedTiles) {
						for(let destroyableTile of currentLevel.destroyableTiles) {
							if(distance(destroyableTile, this) <(this.radius + destroyableTile.width/2)) {
								destroyableTile.destroy();
							}
						}
						this.hasDestroyedTiles = true;
					}

					for(let mine of mines) {
						if(distance(this, mine) < this.radius*1.7) {
							mine.explode();
						}
					}

					if(this.kills && !this.hasKilled) {
						for(let tank of tanks) {
							if(distance(this, tank) < this.radius*2) {
								tank.explode();
							}
						}
						this.hasKilled = true;
					}

					this.time--;
					if(this.time <= 0) {
						this.die();
					}
				}

				draw() {
					circle(this.x, this.y, this.radius, COLORS.red1);
				}

				die() {
					explosions.splice(explosions.indexOf(this), 1);
				}
			}

			// Minornas färg animeras med sinuskurvor vars frekvens ökar exponensielt. När de exploderar sprängs alla
			// pansarvagnar i närheten. Om ett skott träffar en mina så sprängs den direkt.
			class Mine {
				constructor(owner, x, y, time, size=15*TANKSCALE) {
					this.x = x;
					this.y = y;
					this.startTime = time;
					this.time = time;
					this.size = size;
					this.owner = owner;

					mineSound.pause();
					mineSound.currentTime = 0;
					mineSound.play();
				}

				update() {
					this.draw();
					this.time--;
					if(this.time <= 0) {
						this.explode();
					}
				}

				draw() {
					let a = Math.abs(cos(this.startTime/(this.time)+pi/1.5));
					circle(this.x, this.y, this.size*0.98, COLORS.red1);
					circle(this.x, this.y, this.size, "rgba(255, 212, 28, " + a + ")");
				}

				explode() {
					let radius = this.size*2.7;
					explosions.push(new Explosion(this.x, this.y, radius));

					mines.splice(mines.indexOf(this), 1);
					if(this.owner && this.owner.mines > 0)
						this.owner.mines--;
				}
			}

			// Skott som pansarvagnarna kan skjuta. De kollar när de är i närheten av en vägg huruvida de har studsat
			// mot denna vägg och kollar i så fall även vilken sida av väggen den studsade på.
			class Bullet {
				constructor(owner, x, y, angle, speed, maxBounces, color=COLORS.gray1, scale=TANKSCALE) {
					this.x = x;
					this.y = y;
					this.angle = angle;
					this.speed = speed;
					this.maxBounces = maxBounces;
					this.bounces = 0;
					this.color = color;
					this.scale = scale;
					this.tolerance = 50 * this.scale;
					this.owner = owner;
					this.hasCollided = false;
					this.isColliding = false;
					this.vx = cos(this.angle) * this.speed;
					this.vy = sin(this.angle) * this.speed;
					this.collisionDelay = 3/this.speed;
					this.collisionTimer = 0;
					this.lastTile = null;
				}

				update() {
					this.collisionTimer--;
					if(this.x > totalWidth + this.tolerance  || this.x < -this.tolerance  || this.y > totalHeight + this.tolerance  || this.y < -this.tolerance) {
						this.die();
					}  else {
						this.draw();
						this.x += this.vx;
						this.y += this.vy;
					}

					if(this.bounces > this.maxBounces) {
						this.explode();
					}
				}

				draw() {
					save();
					translate(this.x, this.y);
					rotateRadians(this.angle);
					cRectangle(0, 0, 10*this.scale, 5*this.scale, this.color);
					if(DEBUG) {
						text(0, -4, 15, this.bounces + "/" + this.maxBounces, this.color);
					}
					restore();
				}

				explode() {
					let radius = this.scale*10;
					explosions.push(new Explosion(this.x, this.y, radius, false, false, 8));
					this.die();
				}

				die() {
					bullets.splice(bullets.indexOf(this), 1);
					if(this.owner && this.owner.bullets > 0)
						this.owner.bullets--;
				}

				collide(side) {
					if(side.up || side.down) {
						this.vy *= -1;
						this.collisionTimer = this.collisionDelay;
						this.bounces++;
						this.angle = pi-this.angle;
						click.currentTime = 0;
						click.play();
					}

					if(side.left || side.right) {
						this.vx *= -1;
						this.collisionTimer = this.collisionDelay;
						this.bounces++;
						this.angle = pi-this.angle;
						click.currentTime = 0;
						click.play();
					}
				}
			}

			// Den största classen i programmet. Här definieras all logik för hur spelaren kontrollerar sin pansarvagn
			// samt all logik för hur AI:n skall bete sig i olika situationer.
			class Tank {
				constructor(x, y, colors, isPlayer=false, maxBullets=5, maxMines=3, shootDelay=30, bulletSpeedBoost=1, speedBoost=1, maxBulletBounces=1, scale=TANKSCALE) {
					this.x = x;
				  	this.y = y;
					this.isPlayer = isPlayer;
					this.colors = colors;
					this.shootDelay = shootDelay;
					this.shootTimer = 0;
					this.scale = scale;
					this.length = 60*this.scale;
				  	this.width = 45*this.scale;
					this.l2 = this.length/2;
					this.w2 = this.width/2;
				  	this.aimAngle = 0;
				  	this.angle = 0;
					this.hasShot = false;
					this.hasLaidMine = false;
					this.bullets = 0;
					this.maxBullets = maxBullets;
					this.maxMines = maxMines;
					this.speed = 2 * speedBoost;
					this.mines = 0;
					this.canShoot = true;
					this.corner1 = {x:0, y:0, hasCollided:false, isColliding:false};
					this.corner2 = {x:0, y:0, hasCollided:false, isColliding:false};
					this.corner3 = {x:0, y:0, hasCollided:false, isColliding:false};
					this.corner4 = {x:0, y:0, hasCollided:false, isColliding:false};
					this.corners = [];
					this.updateCorners();
					this.trailDelay = 15 * this.scale / this.speed;
					this.trailTimer = 0;
					this.dead = false;
					this.lastTile = null;
					this.recalculatePathDelay = 50;
					this.recalculatePathTimer = 0;
					this.path = [];
					this.pathIndex = 0;
					this.pathAngle = 0;
					this.backing = false;
					this.backingDelay = 18;
					this.backingTimer = 0;
					this.bulletSpeedBoost = bulletSpeedBoost;
					this.maxBulletBounces = maxBulletBounces;
					this.speedBoost = speedBoost;

					if(!this.isPlayer) {
						this.aimAngle = -Math.atan2((this.y-PLAYERTANK.y),(PLAYERTANK.x-this.x));;
					}
				}

				update() {
					let newTile = getTileAtPosition({x:this.x, y:this.y});
					if(this.lastTile != newTile && newTile.tileType != "E"  && newTile.tileType != "H") {
						if(this.lastTile != null)
							this.lastTile.tileType = "_";
						newTile.tileType = (this.dead ? newTile.tileType : (this.isPlayer ? "P" : "E"));
						this.lastTile = newTile;
					}

					this.shootTimer--;

				    if(this.isPlayer) {
						this.aimAngle = -Math.atan2((this.y-mouse.y),(mouse.x-this.x));
						if(GAMEISPLAYING)
							this.playerMovement();
					} else {
						this.aimAngle = -Math.atan2((this.y-PLAYERTANK.y),(PLAYERTANK.x-this.x));
						if(GAMEISPLAYING)
							this.ai();
					}

					drawTank(this.x, this.y, this.angle, this.aimAngle, this.width, this.length, this.colors);
					if(DEBUG) {
						text(this.x, this.y-10, 15, "Bullets:" + this.bullets + "/" + this.maxBullets, COLORS.gray1);
						text(this.x, this.y+10, 15, "Mines:" + this.mines + "/" + this.maxMines, COLORS.gray1);
					}

					this.updateCorners();
					if(DEBUG) {
						for(let corner of this.corners) {
							circle(corner.x, corner.y, 5,(corner.isColliding ? "red" : "green"));
						}
					}
				}

				recalculatePath(efficient=true) {
					let newPath = AStar(getTileAtPosition({x:this.x, y:this.y}), PLAYERTANK.lastTile);
					this.path =  newPath || this.path;

					if(newPath) {
						this.pathIndex = this.path.length-1;

						let nextTile = this.path[this.pathIndex];
						if(efficient) {
							while(this.pathIndex > 0 && this.pointInSight(nextTile)) {
								this.pathIndex--;
								nextTile = this.path[this.pathIndex];
							}

							nextTile = this.path[++this.pathIndex];
						}

						if(nextTile) {
							this.pathAngle = -Math.atan2((this.y-nextTile.y),(nextTile.x-this.x));
						}
					}

					this.recalculatePathTimer = this.recalculatePathDelay;
				}

				ai() {
					let thisTile = getTileAtPosition({x:this.x, y:this.y});
					let nextTile = this.path[this.pathIndex];

					this.recalculatePathTimer--;
					if(this.recalculatePathTimer <= 0 && this.speed > 0) {
						this.recalculatePath();
					}

					if(this.shootTimer <= 0) {
						let boom = this.pointInSight({x:PLAYERTANK.x,y:PLAYERTANK.y}, true);
						if(boom) {
							this.shoot();
						}
					}

					if(nextTile != null && this.speed > 0) {

						if(DEBUG) {
							circle(nextTile.x, nextTile.y, 10, this.colors.gun);
						}

						if((thisTile.gridX == nextTile.gridX && thisTile.gridY == nextTile.gridY)) {
							if(this.pathIndex >= 1) {
								this.pathIndex--;
								nextTile = this.path[this.pathIndex];
								this.pathAngle = -Math.atan2((this.y-nextTile.y),(nextTile.x-this.x));
							}
						} else {
							if(this.corner1.isColliding || this.corner2.isColliding) {
								this.backing = true;
								this.backingTimer = this.backingDelay;
								this.recalculatePath(false);
							} else if (!this.backing) {
								this.x += cos(this.angle) * this.speed;
								this.y += sin(this.angle) * this.speed;
								this.trail();
							}

							this.angle = moveTowards(this.angle, this.pathAngle, 0.03 * this.speedBoost);
						}

						if(this.backing) {
							this.backingTimer--;
							this.angle = moveTowards(this.angle, this.pathAngle, 0.03 * this.speedBoost);
							if(this.backingTimer <= 0) {
								this.backing = false;
								this.backingTimer = this.backingDelay;
								if(this.pathIndex < this.path.length - 1) {
									this.pathIndex++;
									nextTile = this.path[this.pathIndex];
								}
								if(nextTile) {
									this.pathAngle = -Math.atan2((this.y-nextTile.y),(nextTile.x-this.x));
								}
							}

							this.x -= cos(this.angle) * this.speed/2;
							this.y -= sin(this.angle) * this.speed/2;
						}

					}

					if(DEBUG) {
						for(let tile of this.path) {
							circle(tile.x, tile.y, 4, this.colors.body);
						}
					}

				}

				pointInSight(position, checkHoles=false) {
					if(PLAYERTANK.dead) {
						return false;
					}

					if(position.x == null || position.y == null) {
						return false
					}

					let currentCoords = {x:this.x, y:this.y};
					let playerCoords = getTileMapCoordsAtPosition({x:position.x, y:position.y});

					let dist = distance(this, position) / 10;

					let dx = -(this.x - position.x) / dist;
					let dy = -(this.y - position.y) / dist;
					let currentTile = "_";

					if(dist <= 1) {
						return true
					}

					let currentTileCoords = getTileMapCoordsAtPosition({x:currentCoords.x, y:currentCoords.y});
					let startTileCoords = currentTileCoords;

					while((currentTile == "E" && (currentTileCoords.x == startTileCoords.x && currentTileCoords.y == startTileCoords.y)) || (currentTile == "_" || (currentTile == "H" && checkHoles))) {
						if(DEBUG) {
							circle(currentCoords.x, currentCoords.y, 6, "yellow");
						}

						currentCoords.x += dx;
						currentCoords.y += dy;

						currentTileCoords = getTileMapCoordsAtPosition({x:currentCoords.x, y:currentCoords.y});

						if(currentTileCoords.x == playerCoords.x && currentTileCoords.y == playerCoords.y) {
							return true;
						}

						currentTile = getTileAtPosition({x:currentCoords.x, y:currentCoords.y}).tileType;
					}

					return false;
				}

				playerMovement() {
					let turnSpeed = 0.03;

					if((keyboard.up || keyboard.w) && !(this.corner1.isColliding || this.corner2.isColliding)) {
				      	this.x += cos(this.angle) * this.speed;
				      	this.y += sin(this.angle) * this.speed;
						this.trail();
					} else if((keyboard.down || keyboard.s) && !(this.corner3.isColliding || this.corner4.isColliding)) {
				      	this.x -= cos(this.angle) * this.speed;
				      	this.y -= sin(this.angle) * this.speed;
						this.trail();
				    }

					if(keyboard.space && !this.hasLaidMine && this.mines < this.maxMines) {
						mines.push(new Mine(this, this.x, this.y, 400));
						this.mines++;
						this.hasLaidMine = true;
						if(this.isPlayer) {
							STATISTICS.totalMinesLaid++;
						}
				    } else if(!keyboard.space) {
					    this.hasLaidMine = false;
				    }

					if(keyboard.right || keyboard.d) {
						this.angle = moveTowards(this.angle, this.angle + turnSpeed*2, turnSpeed);
					} else if(keyboard.left || keyboard.a) {
						this.angle = moveTowards(this.angle, this.angle - turnSpeed*2, turnSpeed);
					}

					if(mouse.left) {
						if(this.hasShot) {
							if(this.shootTimer <= 0) {
								this.shoot();
							}
						} else {
							this.shoot();
						}
					} else if(!mouse.left) {
						this.hasShot = false;
					}
				}

				trail() {
					this.trailTimer--;
					if(this.trailTimer <= 0) {
						trails.push(new Trail(this.x, this.y, this.angle, this.width*0.8));
						this.trailTimer = this.trailDelay;
						if(this.isPlayer) {
							STATISTICS.distanceTravelled++;
						}
					}
				}

				updateCorners() {
					let c = cos(this.angle)*(this.isPlayer ? 0.85 : 0.7);
					let s = sin(this.angle)*(this.isPlayer ? 0.75 : 0.65);

					let lc = this.l2*c;
					let ls = this.l2*s;
					let wc = this.w2*c;
					let ws = this.w2*s;

					this.corner1.x = this.x + lc + ws;
					this.corner1.y = this.y + ls - wc;

					this.corner2.x = this.x + lc - ws;
					this.corner2.y = this.y + ls + wc;

					this.corner3.x = this.x - lc - ws;
					this.corner3.y = this.y - ls + wc;

					this.corner4.x = this.x - lc + ws;
					this.corner4.y = this.y - ls - wc;

					this.corners = [this.corner1, this.corner2, this.corner3, this.corner4];
				}

				shoot() {
					if(this.bullets < this.maxBullets) {
						bullets.push(new Bullet(this, this.x+cos(this.aimAngle)*this.length/1.3, this.y+sin(this.aimAngle)*this.length/1.3, this.aimAngle, PLAYERTANK.speed*1.2*this.bulletSpeedBoost, this.maxBulletBounces));
						shootSound.pause();
						shootSound.currentTime = 0;
						shootSound.play();
						this.bullets++;
						this.shootTimer = this.shootDelay;
						this.hasShot = true;
						if(this.isPlayer) {
							STATISTICS.totalBulletsFired++;
						}
					}
				}

				explode() {
					let radius = this.scale*50;
					if(!this.dead)
						explosions.push(new Explosion(this.x, this.y, radius, false, false, 13));

					this.die();
				}

				die() {
					tanks.splice(tanks.indexOf(this), 1);
					deadTanks.push(this);
					this.dead = true;

					let newTile = getTileAtPosition({x:this.x, y:this.y});
					newTile.tileType = "_";
				}

				deadUpdate() {
					this.drawMarker();
				}

				drawMarker() {
					save();
					translate(this.x, this.y);
					rotateRadians(this.angle-pi/2);
					cRectangle(0, 0, this.width, this.width/5, COLORS.white);
					rotateRadians(2*pi/4);
					cRectangle(0, 0, this.width, this.width/5, COLORS.white);
					restore();
				}

				isInsideCorners(point) {
					return !(this.isLeft(this.corner1, this.corner2, point) &&
							this.isLeft(this.corner2, this.corner3, point) &&
							this.isLeft(this.corner3, this.corner4, point) &&
							this.isLeft(this.corner4, this.corner1, point));
				}

				isLeft(P0, P1, P2) {
					 return ((P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y));
				}
			}

			// Varje vägg i spelet är en s.k. "Tile". De har en typ som kan vara "_":tom, "B":Block, "b":Block som kan sprängas,
			// "H":Hål, "0"-"9":Fiende (AI), "P":Player Spawnpoint m.m.
			// Varje Tile har definierade ramar som skott skall studsa emot samt pansarvagnar inte skall kunna gå över / genom.
			class Tile {
				constructor(gridX, gridY, x, y, w, h, tileType, neighbours=null) {
					this.x = x;
					this.y = y;
					this.gridX = gridX;
					this.gridY = gridY;
					this.width = w;
					this.height = h;
					this.tileType = tileType;
					this.neighbours = neighbours;
					this.color = this.tileTypeToColor();
					this.halfWidth = this.width/2;
					this.halfHeight = this.height/2;
					this.cornerX = x - this.halfWidth;
					this.cornerY = y - this.halfHeight;
					this.destroyable = (tileType == tileType.toLowerCase());
					this.destroyed = false;
					this.timer = 30;
					this.neighbouringTiles = { up:null, down:null, left:null, right:null };

					// A* (AI variables)
					this.previous = null;
					this.f = 0;
					this.g = 0;
					this.h = 0;
				}

				tileTypeToColor(tileType=this.tileType) {
					switch(tileType) {
						default:
						case "B":
							return COLORS.sand4;
							break;
						case "b":
							return COLORS.sand1;
							break;
						case "H":
							return COLORS.gray2;
							break;
					}
				}

				destroy() {
					if(this.destroyable) {
						this.destroyed = true;
						this.tileType = "_";
					}
				}

				pointCollides(position) {
					if(this.destroyed)
						return false;

					let collides = false;

					if(this.tileType.toUpperCase() == "H") {
						collides = (distance(position, this) < this.width/2.3)
						return collides;
					}

					collides = (position.x >= this.cornerX && position.x <= this.cornerX + this.width && position.y >= this.cornerY && position.y <= this.cornerY + this.height);
					return collides;
				}

				getSideOfCollision(position) {
					let side = {up:false, down:false, left:false, right:false};

					let collisionBoxWidth = this.halfWidth/6;

					if(DEBUG) {
						cRectangle(this.x, this.y, collisionBoxWidth*2, collisionBoxWidth*2, COLORS.green1);
					}

					if(!this.neighbours.up && position.x >= this.cornerX && position.x <= this.cornerX + this.width && position.y >= this.cornerY && position.y <= this.cornerY + collisionBoxWidth) {
						side.up = true;
					} else if(!this.neighbours.down && position.x >= this.cornerX && position.x <= this.cornerX + this.width && position.y >= this.cornerY+this.height-collisionBoxWidth && position.y <= this.cornerY + this.height) {
						side.down = true;
					} else if(!this.neighbours.left && position.x >= this.cornerX && position.x <= this.cornerX + collisionBoxWidth && position.y >= this.cornerY && position.y <= this.cornerY + this.height) {
						side.left = true;
					} else if(!this.neighbours.right && position.x >= this.cornerX + this.width - collisionBoxWidth && position.x <= this.cornerX + this.width && position.y >= this.cornerY && position.y <= this.cornerY + this.height) {
						side.right = true;
					}

					return side;
				}

				update() {
					this.draw();
				}

				draw(tileType=this.tileType) {
					if(this.destroyed) {

					} else {
						switch(tileType) {
							default:
								cRectangle(this.x, this.y, this.width, this.height, this.color);
								break;
							case "H":
								circle(this.x, this.y, this.width/3, COLORS.gray2);
								circle(this.x, this.y, this.width/4, COLORS.gray1);
								break;
						}
						if(DEBUG) {
							circle(this.x, this.y, 5, COLORS.gray0);
							if(this.neighbours.up) {
								line(this.x, this.y, this.x, this.y-this.halfHeight/2, 2, COLORS.gray0);
								circle(this.x, this.y-this.halfHeight/2, 3, COLORS.gray0);
							}
							if(this.neighbours.down) {
								line(this.x, this.y, this.x, this.y+this.halfHeight/2, 2, COLORS.gray0);
								circle(this.x, this.y+this.halfHeight/2, 3, COLORS.gray0);
							}
							if(this.neighbours.left) {
								line(this.x, this.y, this.x-this.halfWidth/2, this.y, 2, COLORS.gray0);
								circle(this.x-this.halfWidth/2, this.y, 3, COLORS.gray0);
							}
							if(this.neighbours.right) {
								line(this.x, this.y, this.x+this.halfWidth/2, this.y, 2, COLORS.gray0);
								circle(this.x+this.halfWidth/2, this.y, 3, COLORS.gray0);
							}
						}
					}
				}
			}

			// Definiering av lla globala variabler som skall vara tillgängliga för alla fuktioner under hela processen. Bl.a. inställningar,
			// statistik, färger, musik, spelarens liv och mycket mer.
			// #region Variables
			updatesPerSecond = 60;
			var DEBUG = false;
			canvas.getContext("2d").textAlign = "center";

			const COLORS = {
				red1:"rgba(200, 10, 50, 1)",
				red2:"rgba(130, 2, 20, 1)",
				red3:"rgba(190, 8, 40, 1)",
				blue1:"rgba(110, 110, 180, 1)",
				blue2:"rgba(80, 80, 190, 1)",
				blue3:"rgba(60, 60, 195, 1)",
				brown1:"rgba(137, 95, 67, 1)",
				brown2:"rgba(171, 119, 84, 1)",
				brown3:"rgba(179, 132, 101, 1)",
				green1:"rgba(70, 156, 48, 1)",
				green2:"rgba(78, 176, 54, 1)",
				green3:"rgba(104, 201, 79, 1)",
				orange1:"rgba(211, 84, 0, 1)",
				orange2:"rgba(230, 126, 34, 1)",
				orange3:"rgba(243, 156, 18, 1)",
				yellow1:"rgba(255, 212, 28, 1)",
				sand1:"rgba(227, 185, 130, 1)",
				sand2:"rgba(236, 204, 162, 1)",
				sand3:"rgba(231, 196, 150, 1)",
				sand4:"rgba(225, 191, 146, 1)",
				gray0:"rgba(85, 85, 85, 0.4)",
				gray1:"rgba(55, 55, 55, 1)",
				gray2:"rgba(85, 85, 85, 1)",
				gray3:"rgba(200, 200, 200, 1)",
				white1:"rgba(250, 250, 250, 1)",
				white2:"rgba(210, 210, 210, 1)",
				white3:"rgba(230, 230, 230, 1)",
				white:"rgba(230, 230, 230, 1)",
				startcolor:"rgba(40, 40, 40, 0.4)",
				endColor:"rgba(120, 100, 120, 0.01)"
			};

			const TANKCOLORS1 = tankColors(COLORS.orange1, COLORS.orange2, COLORS.orange3);
			const TANKCOLORS2 = tankColors(COLORS.brown1, COLORS.brown2, COLORS.brown3);
			const TANKCOLORS3 = tankColors(COLORS.green1, COLORS.green2, COLORS.green3);
			const TANKCOLORS4 = tankColors(COLORS.red2, COLORS.red1, COLORS.red3);
			const TANKCOLORS5 = tankColors(COLORS.blue3, COLORS.blue2, COLORS.blue1);
			const TANKCOLORS6 = tankColors(COLORS.white3, COLORS.white2, COLORS.white1);

			var enemyTankColors = [
				TANKCOLORS2,
				TANKCOLORS1,
				TANKCOLORS4,
				TANKCOLORS5,
				TANKCOLORS6,
			];

			const TANKSCALE = totalHeight/700;
			const STARTDELAY = 180;
			const WINDELAY = 150;
			let startTimer = STARTDELAY;
			let winTimer = WINDELAY;
			var backgroundMusic = new Audio("http://23.237.126.42/ost/wii-play/qqvrntybtr/053%20-%20Tanks%20-%20Variation%201.mp3");
			var winMusic = new Audio("http://23.237.126.42/ost/wii-play/howmzfluwp/055%20-%20Tanks%20-%20Round%20End.mp3");
			var deathMusic = new Audio("http://23.237.126.42/ost/wii-play/xigbgdonrb/054%20-%20Tanks%20-%20Round%20Failure.mp3");
			var statsMusic = new Audio("http://23.237.126.42/ost/wii-play/saxordnvfk/068%20-%20Tanks%20-%20Results.mp3");
			var smallExplosion = new Audio("https://www.zapsplat.com/wp-content/uploads/2015/sound-effects-audio-hero/audio_hero_ExplosionSmall_DIGIJ02_24_351.mp3?_=9");
			var shootSound = new Audio("https://www.zapsplat.com/wp-content/uploads/2015/sound-effects-27787/zapsplat_leisure_inflatable_toy_puncture_002_28944.mp3");
			var click = new Audio("https://www.zapsplat.com/wp-content/uploads/2015/sound-effects-one/multimedia_button_click_007.mp3");
			var mineSound = new Audio("https://www.zapsplat.com/wp-content/uploads/2015/sound-effects-skyclad-sound/skyclad_sound_pop_then_squeak_squawk_descend_281.mp3");

			var PLAYERTANK = new Tank(0, 0, TANKCOLORS3, true);
			var PLAYERLIVES = 3;

			var STATISTICS = {
				totalBulletsFired:0,
				totalMinesLaid:0,
				totalEnemiesKilled:0,
				distanceTravelled:0
			};

			var GAMEISPLAYING = false;
			var START = false;
			var HASINITIATEDLEVEL = false;
			var HASSTARTEDONCE = false;
			var GAMEOVER = false;
			var GAMEOVERTIME = 0;

			var hasWon = false;

			let hasPlayedMusic = false;
			let tanks = [];
			let deadTanks = [];
			let bullets = [];
			let mines = [];
			let explosions = [];

			let trails = [];
			let died = false;

			// #endregion

			// Diverse funktioner som underlättar beräkningar eller ritande av exempelvis pansarvagnar.
			// #region Helper functions

			function drawTank(x, y, angle, aimAngle, width, length, colors, enemy=false) {
				save();
				translate(x, y);
				rotateRadians(angle);
				cRectangle(0, 0, length, width, colors.body);

				cRectangle(0, 0, width/3, width/1.5, colors.gun);
				cRectangle(0, width/3, length, width/8, colors.head);
				cRectangle(0, -width/3, length, width/8, colors.head);

				//circle(length/3, 0, 5, colors.gun);
				triangle(length/4, width/4, length/4, -width/4, length/2.3, 0, colors.head);

				rotateRadians(aimAngle-angle);
				cRectangle(0, 0, width/2, width/2, colors.head);
				cRectangle(length/2.12, 0, length/1.6, width/7, colors.gun);
				cRectangle(length/1.3, 0, width/4, width/4, colors.gun);
				restore();
			}

			function moveTowards(current, target, maxDelta) {
				if(Math.abs(target - current) <= maxDelta) {
					return target;
				}
				return current + Math.sign(target - current) * maxDelta * getTurnDirection(current, target);
			}

			function getTurnDirection(current, target) {
				let diff =(target - current)%(2*pi);
				return(Math.abs(diff) > pi ? -1 : 1);
			}

			function cRectangle(x, y, w, h, color) {
				rectangle(x-w/2, y-h/2, w, h, color);
			}

			function tankColors(bodyc, headc, gunc) {
				return {
					body:bodyc,
					head:headc,
					gun:gunc
				};
			}

			// #endregion

			// Funktioner som skapar och definierar alla nivåer utifrån MAP-arrayerna av strings nedan. (Skapar objekt som har mer information)
			// och som är lättare att använda
			// #region Level
			function createLevel(MAP) {
				let level = {
					name:MAP.name,
					height:MAP.map.length,
					width:MAP.map[0].length,
					tileWidth:totalWidth/MAP.map[0].length,
					tileHeight:totalHeight/MAP.map.length,
					map:MAP.map,
					tileMap:[],
					tiles:[],
					destroyableTiles:[],
					holes:[],
					playerSpawnpoint:{x:0,y:0},
					tanks:[],
				};

				level.tileMap = new Array(level.height);

				for(let y = 0; y < level.height; y++) {
					level.tileMap[y] = new Array(level.width);
				}

				for(let x = 0; x < level.width; x++) {
					for(let y = 0; y < level.height; y++) {
						let tileType = level.map[y][x];

						let tileNeighbours;
						let newTile = new Tile(x, y, level.tileWidth/2 + x*level.tileWidth, level.tileHeight/2 + y*level.tileHeight, level.tileWidth, level.tileHeight, tileType);

						let neighbours = {up:false, down:false, left:false, right:false};

						neighbours.left = (x-1 < 0) || (level.map[y][x-1] == "B");
						neighbours.right = (x+1 >= level.width) || (level.map[y][x+1] == "B");
						neighbours.up = (y-1 < 0) || (level.map[y-1][x] == "B");
						neighbours.down = (y+1 >= level.height) || (level.map[y+1][x] == "B");

						newTile.neighbours = neighbours;

						level.tileMap[y][x] = (newTile);

						if(tileType != "_") {
							if(tileType.toUpperCase() == "P") {
								level.playerSpawnpoint.x = newTile.x;
								level.playerSpawnpoint.y = newTile.y;
						    } else if(tileType.toUpperCase() == "H") {
							    level.holes.push(newTile);
							    level.tiles.push(newTile);
						    } else if (tileType == "0") {
							    // constructor(x, y, colors, isPlayer=false, maxBullets=5, maxMines=3, shootDelay=30, bulletSpeedBoost=1, speedBoost=1, maxBulletBounces=1, scale=TANKSCALE) {
								level.tanks.push(new Tank(newTile.x, newTile.y, enemyTankColors[tileType], false, 1, 0, 10));
							} else if (tileType == "1") {
								level.tanks.push(new Tank(newTile.x, newTile.y, enemyTankColors[tileType], false, 3, 0, 60));
							} else if (tileType == "2") {
								level.tanks.push(new Tank(newTile.x, newTile.y, enemyTankColors[tileType], false, 1, 0, 30, 2));
							} else if (tileType == "3") {
								level.tanks.push(new Tank(newTile.x, newTile.y, enemyTankColors[tileType], false, 3, 0, 30, 2.1, 1.8));
							} else if (tileType == "4") {
								level.tanks.push(new Tank(newTile.x, newTile.y, enemyTankColors[tileType], false, 8, 0, 130, 3.5, 0, 5));
							} else {
								if(newTile.destroyable) {
									level.destroyableTiles.push(newTile);
								}
								level.tiles.push(newTile);
							}
						}
					}
				}

				for(let x = 0; x < level.width; x++) {
					for(let y = 0; y < level.height; y++) {
						let neighbouringTiles = level.tileMap[y][x].neighbouringTiles;

						neighbouringTiles.left = (x-1 < 0 ? null : level.tileMap[y][x-1]);
						neighbouringTiles.right = (x+1 >= level.width ? null : level.tileMap[y][x+1]);
						neighbouringTiles.up = (y-1 < 0 ? null : level.tileMap[y-1][x]);
						neighbouringTiles.down = (y+1 >= level.height ? null : level.tileMap[y+1][x]);

						level.tileMap[y][x].neighbouringTiles = neighbouringTiles;
					}
				}

				return level;
			}

			function setLevels() {
				for(let MAP of MAPS) {
					LEVELS.push(createLevel(MAP));
				}
			}

			function resetLevel(id) {
				tanks = [];
				currentLevel.tanks = [];
				LEVELS[id] = createLevel(MAPS[id]);
			}

			function restart() {
				resetLevel(currentLevelId);
				currentLevelId--;
				PLAYERLIVES--;
				if(PLAYERLIVES <= 0) {
					gameOver();
				} else {
					nextLevel();
				}
			}

			function nextLevel() {
				GAMEISPLAYING = false;
				HASINITIATEDLEVEL = false;
				hasPlayedMusic = false;
				backgroundMusic.pause();
				backgroundMusic.currentTime = 0;
				winMusic.pause();
				winMusic.currentTime = 0;
				deathMusic.pause();
				deathMusic.currentTime = 0;

				if(currentLevelId != LEVELS.length - 1) {
					currentLevelId++;
				} else {
					return win ();
				}

				PLAYERTANK.angle = 0;
				PLAYERTANK.trails = [];
				PLAYERTANK.bullets = 0;
				PLAYERTANK.mines = 0;
				PLAYERTANK.dead = false;
				bullets = [];
				mines = [];
				deadTanks = [];
				tanks = [];
				trails = [];

				currentLevel = LEVELS[currentLevelId];
				startTimer = STARTDELAY;
				winTimer = WINDELAY;
				hasWon = false;
				died = false;
			}

			function getTileMapCoordsAtPosition(position) {
				let x = Math.round(0.5 + position.x/currentLevel.tileWidth)-1;
				let y = Math.round(0.5 + position.y/currentLevel.tileHeight)-1;

				return {x:x, y:y};
			}

			function getTileAtPosition(position, debug=false) {
				let coords = getTileMapCoordsAtPosition(position);

				let tile = currentLevel.tileMap[coords.y][coords.x];

				if(DEBUG && debug) {
					cRectangle(currentLevel.tileWidth/2 + coords.x*currentLevel.tileWidth, currentLevel.tileHeight/2 + coords.y*currentLevel.tileHeight, currentLevel.tileWidth, currentLevel.tileHeight, COLORS.gray0);
				}

				return tile;
			}
			// #endregion

			// A* är en sökalgoritm som letar efter den kortaste / mest effektiva vägen att ta sig från punk A till punkt B i ett system
			// av noder. Denna funktion har jag implementerat själv ifrån pseudo-kod som finns på https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode
			// Jag har tidigare erfarenhet av denna algoritm och ansåg den lämplig för AI:ns ändamål.
			// #region A*
			function heuristic(tile, goal) {
				//return Math.abs(tile.x-goal.x) + Math.abs(tile.y-goal.y);
				//return(tile.x-goal.x)*(tile.y-goal.y);
				return distance(tile, goal);
			}

			function AStarPath(current, start, l=30) {
				let path = [];
				let temp = current;
				for(let i = 0; i < l; i++) {

					if(temp.previous == null) {
						break;
					}

					if(temp != start)
						path.push({x:temp.previous.x, y:temp.previous.y, gridX:temp.previous.gridX, gridY:temp.previous.gridY});

					temp = temp.previous;
				}
				return path;
			}

			function AStar(start=currentLevel.tileMap[1][1], goal=currentLevel.tileMap[currentLevel.height-1][currentLevel.width-1]) {
				let closedSet = [];
				let openSet = [start];

				for(let tile of currentLevel.tileMap) {
					tile.f = 0;
					tile.g = 0;
					tile.h = 0;
					tile.previous = null;
				}

				start.f = heuristic(start, goal);

				let i = 0;
				while(openSet.length > 0 && i < currentLevel.height*currentLevel.width*5) {
					i++;

					let nodeWithLowest = start;

					for(let open of openSet) {
						if(open.f < nodeWithLowest.f) {
							nodeWithLowest = open;
						}
					}

					let current = nodeWithLowest;

					if(current.gridX == goal.gridX && current.gridY == goal.gridY) {
						return AStarPath(current, start, i);
					}

					openSet.splice(openSet.indexOf(current), 1);
					closedSet.push(current);

					for(let key in current.neighbouringTiles) {
						let neighbouringTile = current.neighbouringTiles[key];
						if (neighbouringTile != null && neighbouringTile.tileType != "E" && (neighbouringTile.tileType == "_" || neighbouringTile.tileType == "P")) {

							if(closedSet.includes(neighbouringTile)) {
								continue;
							}

							let tentativeGScore = current.g + 1;

							if(!openSet.includes(neighbouringTile)) {
								openSet.push(neighbouringTile);
							} else if(tentativeGScore > neighbouringTile.g) {
								continue;
							}

							neighbouringTile.previous = current;
							neighbouringTile.g = tentativeGScore;
							neighbouringTile.h = heuristic(neighbouringTile, goal);
							neighbouringTile.f = neighbouringTile.g + neighbouringTile.h;
						}
					}
				}

				// no solution
				// console.log("It is impossible to complete the path. : " + i);
				return;
			}

			// #endregion

			// Här definieras alla banor i string-arrayer. Varje bokstav / karaktär representerar en typ av Tile (vägg-typ)
			// #region Maps

			const EMPTYMAP = {
				name:"EMPTY",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B___________________B",
					"B___________________B",
					"B___________________B",
					"B___________________B",
				/*M*/"B___________________B",
					"B___________________B",
					"B___________________B",
					"B___________________B",
					"B_P_________________B",
					"B___________________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP1 = {
				name:"It Begins",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B___________________B",
					"B_____B___B___B_____B",
					"B_____B___B___H_____B",
					"B_________b___B_____B",
			   /*M*/"B___P_____b___b__0__B",
					"B_________b___B_____B",
					"B_____B___B___H_____B",
					"B_____B___B___B_____B",
					"B___________________B",
					"B___________________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP2 = {
				name:"Walls",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B_________________1_B",
					"B___________________B",
					"B______________B____B",
					"B______________BBB__B",
				/*M*/"B___________________B",
					"B__BBB______________B",
					"B____B______________B",
					"B___________________B",
					"B_P_________________B",
					"B___________________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP3 = {
				name:"Red",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B________________2__B",
					"B___________________B",
					"B___BBHBHBBBBBBBB___B",
					"B___________________B",
				/*M*/"B________________1__B",
					"B___________________B",
					"B___BBBBBBBBHBHBB___B",
					"B___________________B",
					"B_P______________0__B",
					"B___________________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP4 = {
				name:"Hole-y...",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___H___H___________B",
					"B___H_0_H________1__B",
					"B___H___H___________B",
					"BH_HHHHHH___________B",
					"B___________________B",
				/*M*/"B___H_______________B",
					"B___H_______________B",
					"B_bbB___________HHHHB",
					"B___b_______________B",
					"B_P_b_____________0_B",
					"B_______________H___B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP5 = {
				name:"2 Red 1 Brown",
				map:[
					/*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B________________2__B",
					"B___________________B",
					"B___BbBbBHBHBBBBBBBBB",
					"B___________________B",
				/*M*/"B_2_________________B",
					"B___________________B",
					"BBBBBBBBBHBHBbBbB___B",
					"B___________________B",
					"B_P__b____________0_B",
					"B___________________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP6 = {
				name:"Symmetry",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B_________2____B____B",
					"B__BHBB________B____B",
					"B_____B_BbbbB__B__0_B",
					"B_____BBB___B_BB____B",
				/*M*/"B_________P_________B",
					"B_____BBB___B_BB____B",
					"B_____B_BbbbB__B__0_B",
					"B__BHBB________B____B",
					"B_________2____B____B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP7 = {
				name:"Now We're Talking",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B_0_H____________2__B",
					"B___H_______________B",
				/*M*/"B___H____________1__B",
					"B___H_______________B",
					"B_P_H____________2__B",
					"B___H_______________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP8 = {
				name:"Blue",
				map:[
				    /*_______M______*/
					"BBBBBBBBBBBBBBB",
					"B______0______B",
					"B___H_____H___B",
					"B______3______B",
					"B_____________B",
					"B___H_____H___B",
			   /*M*/"BBB___bbb___BBB",
					"B___H_____H___B",
					"B_____________B",
					"B_____________B",
					"B___H__P__H___B",
					"B_____________B",
					"BBBBBBBBBBBBBBB",
				]
			};

			const MAP9 = {
				name:"Battlefield",
				map:[
				    /*________M________*/
					"BBBBBBBBBBBBBBBBBB",
					"B____B___________B",
					"B____B_b_____B_2_B",
					"B____B_H___H_B___B",
					"B____________B___B",
					"B______H___H_____B",
			   /*M*/"B_P_b____b_____3_B",
					"B______H___H_____B",
					"B____________B___B",
					"B____B_H___H_B___B",
					"B____B_b_____B_2_B",
					"B____B___________B",
					"BBBBBBBBBBBBBBBBBB",
				]
			};

			// Johannes COOP Level creation
			const MAP10 = {
				name:"Luigi's Mansion - By Johannes",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B_2_______________0_B",
					"B_________________0_B",
					"B_________________0_B",
					"B__BB_____________0_B",
			   /*M*/"B___B_______________B",
					"B___B_______________B",
					"B___BBHBHBB_________B",
					"B___B_____B_________B",
					"B______P__B______3__B",
					"B_________B_________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP11 = {
				name:"Wall 2.0",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B________B__________B",
					"B________H__B____3__B",
					"B___________B_______B",
					"B________H__B_______B",
					"B________b_______2__B",
			   /*M*/"B_____P__b__________B",
					"B________b_______2__B",
					"B________H__B_______B",
					"B___________B_______B",
					"B________H__B____3__B",
					"B________B__________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP13 = {
				name:"White",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B________________4__B",
					"B___________________B",
					"B___________________B",
					"B___________________B",
				/*M*/"B___________________B",
					"B___________________B",
					"B___________________B",
					"B___________________B",
					"B_P_________________B",
					"B___________________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP15 = {
				name:"Whiter",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B_________B_4_______B",
					"B_________b_________B",
					"B_________B_________B",
					"B_BbbBB____________4B",
					"B_____B_____________B",
				/*M*/"B_P___b_________3___B",
					"B_____B_____________B",
					"B_BbbBB____________4B",
					"B_________B_________B",
					"B_________b_________B",
					"B_________B_4_______B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			var MAPS = [
				// EMPTYMAP,
				MAP1,
				MAP2,
				MAP3,
				MAP4,
				MAP5,
				MAP6,
				MAP7,
				MAP8,
				MAP9,
				MAP10,
				MAP11,
				// MAP12,
				MAP13,
				// MAP14,
				MAP15
			];

			var LEVELS = [];
			setLevels();

			let currentLevelId = 0;
			var currentLevel = LEVELS[currentLevelId];

			// #endregion

			// Update-funktionen ser till att alla objekt som finns instantierade blir kallade för att kunna genomföra sina uppgifter
			// kontinuerligt. Här sker även all logik för musik, statistik, animationer och texter som spelaren tar del av.
			function update() {
				if(GAMEOVER) {
					let y = totalHeight*1.3 - GAMEOVERTIME;
					let texty = (y <= totalHeight/4 ? totalHeight/4 : y);
					let x = totalWidth/2;

					rectangle(totalWidth/4, y-150, totalWidth-totalWidth/2, totalHeight*2, COLORS.gray1);

					circle(x, totalHeight/2, totalWidth, COLORS.endColor);
					text(x, texty, 80, (currentLevelId + 1 == LEVELS.length ? "YOU WIN" : "GAME OVER"), COLORS.white);
					texty += 100;
					text(x, texty, 60, "Statistics", COLORS.white);
					text(x, texty+60, 30, "Bullets Fired : " + STATISTICS.totalBulletsFired, COLORS.white);
					text(x, texty+90, 30, "Mines Laid : " + STATISTICS.totalMinesLaid, COLORS.white);
					text(x, texty+120, 30, "Distance Travelled : " + STATISTICS.distanceTravelled, COLORS.white);
					text(x, texty+200, 30, "Missions Cleared : " + (currentLevelId + 1) + " / " + LEVELS.length, COLORS.white);

					texty += 160;
					text(x, texty+100, 20, "A Game Clone by: ErikWDev");
					text(x, texty+130, 20, "And a level by: J.G.");
					text(x, texty+180, 20, "All music is owned by Nintendo (tm).");
					text(x, texty+210, 20, "All rights reserved.");
					GAMEOVERTIME++;
				} else {
					if(!HASINITIATEDLEVEL) {
						START = (DEBUG || HASSTARTEDONCE);
						PLAYERTANK.x = currentLevel.playerSpawnpoint.x;
						PLAYERTANK.y = currentLevel.playerSpawnpoint.y;
						currentLevel.tanks.push(PLAYERTANK);
						tanks = currentLevel.tanks;

						for(let tank of tanks) {
							if(tank != PLAYERTANK) {
								tank.angle = (tank.x > PLAYERTANK.x ? pi : 0);
							}
						}
						HASINITIATEDLEVEL = true;
					}

					if(START) {
						GAMEISPLAYING = (startTimer <= 0);

						graphicsAndCollisions();

						if(!hasPlayedMusic) {
							backgroundMusic.pause();
							backgroundMusic.play();
							hasPlayedMusic = true;
						}

						if(!GAMEISPLAYING) {
							startTimer -= 0.8;
							circle(totalWidth/2, totalHeight/2, (startTimer*startTimer)*10, COLORS.startcolor);
							text(totalWidth/2, totalHeight/2, 120 - currentLevel.name.length*3, currentLevel.name, COLORS.white);
							text(totalWidth/2, totalHeight/2 + 80, 50, "Mission: " + (currentLevelId + 1) + " / " + LEVELS.length, COLORS.white);
							text(totalWidth/2, totalHeight/2 + 160, 50, "Tanks: " + (tanks.length - 1), COLORS.white);
							text(totalWidth/2, totalHeight/2 - 120, 50, "Lives: " + PLAYERLIVES, COLORS.white);
						} else {
							let info =  "Lives: " + PLAYERLIVES + " Mission: " + (currentLevelId + 1) + " – " + currentLevel.name;
							text(totalWidth/2, totalHeight-currentLevel.tileHeight/4, currentLevel.tileHeight/2, info, COLORS.white);
							if(tanks.length <= 1) {
								if(tanks[0] == PLAYERTANK) {
									hasWon = true;
								}
							}

							if(hasWon || died) {
								winTimer -= 0.8;
								backgroundMusic.pause();
								if(!winMusic.ended && !deathMusic.ended) {
									if(hasWon) {
										winMusic.loop = false;
										winMusic.play();
									} else {
										if(died) {
											deathMusic.loop = false;
											deathMusic.play();
										}
									}
								}

								let t = WINDELAY*WINDELAY*0.2-(winTimer*winTimer)*0.2;
								circle(totalWidth/2, totalHeight/2, t, COLORS.startcolor);
								if(winTimer <= 0) {
									if(hasWon) {
										nextLevel();
									} else {
										restart();
									}
								}
							}
						}
					} else {
						clearScreen();
						circle(totalWidth/2, totalHeight/2, 130, COLORS.red1);
						text(totalWidth/2, totalHeight/2, 15, "Click here to start!", COLORS.white);
						if(distance(totalWidth/2, totalHeight/2, mouse.x, mouse.y) < 130 && mouse.left) {
							START = true;
							HASSTARTEDONCE = true;
						}
					}
				}
			}

			function graphicsAndCollisions() {
				fill(COLORS.sand2);

				for(let hole of currentLevel.holes) {
					hole.update();
				}

				for(let trail of trails) {
					trail.update();
				}

				for(let deadTank of deadTanks) {
					deadTank.deadUpdate();
					if(deadTank.isPlayer && !hasWon) {
						died = true;
					}
				}

				for(let bullet of bullets) {

					bullet.update();

					for(let mine of mines) {
						if((bullet.x - mine.x)*(bullet.x - mine.x) + (bullet.y - mine.y)*(bullet.y-mine.y) < mine.size*mine.size) {
							bullet.die();
							mine.explode();
						}
					}
				}

				for(let mine of mines) {
					mine.update();
				}

				for(let tank of tanks) {
					for(let corner of tank.corners) {
						corner.isColliding = corner.hasCollided;
						corner.hasCollided = false;
					}

					tank.update();
				}

				for(let explosion of explosions) {
					explosion.update();
				}

				for(let tile of currentLevel.tiles) {
					if(tile.tileType.toUpperCase() != "H")
						tile.update();

					for(let tank of tanks) {
						if((tank.x - tile.x)*(tank.x - tile.x) + (tank.y - tile.y)*(tank.y-tile.y) < 25000) {
							for(let corner of tank.corners) {
								if(!corner.hasCollided) {
									corner.hasCollided = tile.pointCollides(corner);
								}
							}
						}
					}

					for(let bullet of bullets) {
						if(bullet.collisionTimer <= 0 && !tile.destroyed && tile.tileType.toUpperCase() != "H") {
							if((bullet.x - tile.x)*(bullet.x - tile.x) + (bullet.y - tile.y)*(bullet.y - tile.y) < 90*90) {
								bullet.collide(tile.getSideOfCollision(bullet));
							}
						}

						for(let bullet2 of bullets) {
							if(bullet2 != bullet) {
								let sqrDistance = (bullet2.x - bullet.x)*(bullet2.x - bullet.x) + (bullet2.y - bullet.y)*(bullet2.y-bullet.y)
								let r = (TANKSCALE*TANKSCALE)*6.5*2;

								if(sqrDistance < r) {
									bullet.explode();
									bullet2.explode();
								}
							}
						}

						for(let tank of tanks) {

							let radius = TANKSCALE*27;
							let sqrDistance = (tank.x - bullet.x)*(tank.x - bullet.x) + (tank.y - bullet.y)*(tank.y-bullet.y);

							if(sqrDistance < radius*radius) {
								bullet.explode();
								tank.explode();
							}
						}
					}
				}
			}

			function win() {
				statsMusic.play();
				GAMEOVER = true;
			}

			function gameOver() {
				statsMusic.play();
				GAMEOVER = true;
			}

		</script>
	</body>
</html>
