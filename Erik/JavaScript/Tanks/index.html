<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>
		<meta charset="utf-8">
		<title>Tanks Game</title>
	</head>
	<body>
		<script src="https://koda.nu/simple.js">
			updatesPerSecond = 60;

			class Trail {
				constructor(x, y, angle, size) {
					this.x = x;
					this.y = y;
					this.angle = angle;
					this.size = size;
				}

				update() {
					this.draw();
				}

				draw() {
					save();
					translate(this.x, this.y);
					rotateRadians(this.angle);
					let s = this.size/2.5;
					cRectangle(0, s, this.size/7, s, "rgba(0, 0, 0, 0.3)");
					cRectangle(0, -s, this.size/7, s, "rgba(0, 0, 0, 0.3)");
					restore();
				}
			}


			class Explosion {
				constructor(x, y, radius, destroyTiles=true, kills=true, time=20) {
					this.x = x;
					this.y = y;
					this.radius = radius;
					this.time = time;
					this.destroyTiles = destroyTiles;
					this.hasDestroyedTiles = false;
					this.kills = kills;
					this.hasKilled = false;
				}

				update() {
					this.draw();

					if(this.destroyTiles && !this.hasDestroyedTiles) {
						for(let destroyableTile of currentLevel.destroyableTiles) {
							if(distance(destroyableTile, this) <(this.radius + destroyableTile.width/2)) {
								destroyableTile.destroy();
							}
						}
						this.hasDestroyedTiles = true;
					}

					for(let mine of mines) {
						if(distance(this, mine) < this.radius*1.7) {
							mine.explode();
						}
					}

					if(this.kills && !this.hasKilled) {
						for(let tank of tanks) {
							if(distance(this, tank) < this.radius*2) {
								tank.explode();
							}
						}
						this.hasKilled = true;
					}

					this.time--;
					if(this.time <= 0) {
						this.die();
					}
				}

				draw() {
					circle(this.x, this.y, this.radius, COLORS.red1);
				}

				die() {
					explosions.splice(explosions.indexOf(this), 1);
				}
			}


			class Mine {
				constructor(owner, x, y, time, size=15*TANKSCALE) {
					this.x = x;
					this.y = y;
					this.startTime = time;
					this.time = time;
					this.size = size;
					this.owner = owner;
				}

				update() {
					this.draw();
					this.time--;
					if(this.time <= 0) {
						this.explode();
					}
				}

				draw() {
					let a = Math.abs(cos(this.startTime/(this.time)+pi/1.5));
					circle(this.x, this.y, this.size*0.98, COLORS.red1);
					circle(this.x, this.y, this.size, "rgba(255, 212, 28, " + a + ")");
				}

				explode() {
					let radius = this.size*2.7;
					explosions.push(new Explosion(this.x, this.y, radius));

					mines.splice(mines.indexOf(this), 1);
					if(this.owner && this.owner.mines > 0)
						this.owner.mines--;
				}
			}


			class Bullet {
				constructor(owner, x, y, angle, speed, maxBounces, color=COLORS.gray1, scale=TANKSCALE) {
					this.x = x;
					this.y = y;
					this.angle = angle;
					this.speed = speed;
					this.maxBounces = maxBounces;
					this.bounces = 0;
					this.color = color;
					this.scale = scale;
					this.tolerance = 50 * this.scale;
					this.owner = owner;
					this.hasCollided = false;
					this.isColliding = false;
					this.vx = cos(this.angle) * this.speed;
					this.vy = sin(this.angle) * this.speed;
					this.collisionDelay = 2;
					this.collisionTimer = 0;
					this.lastTile = null;
				}

				update() {
					this.collisionTimer--;
					if(this.x > totalWidth + this.tolerance  || this.x < -this.tolerance  || this.y > totalHeight + this.tolerance  || this.y < -this.tolerance) {
						this.die();
					}  else {
						this.draw();
						this.x += this.vx;
						this.y += this.vy;
					}

					if(this.bounces > this.maxBounces) {
						this.explode();
					}
				}

				draw() {
					save();
					translate(this.x, this.y);
					rotateRadians(this.angle);
					cRectangle(0, 0, 10*this.scale, 5*this.scale, this.color);
					if(DEBUG) {
						text(0, -4, 15, this.bounces + "/" + this.maxBounces, this.color);
					}
					restore();
				}

				explode() {
					let radius = this.scale*10;
					explosions.push(new Explosion(this.x, this.y, radius, false, false, 8));
					this.die();
				}

				die() {
					bullets.splice(bullets.indexOf(this), 1);
					if(this.owner && this.owner.bullets > 0)
						this.owner.bullets--;
				}

				collide(side) {
					if(side.up || side.down) {
						this.vy *= -1;
						this.collisionTimer = this.collisionDelay;
						this.bounces++;
						this.angle = pi-this.angle;
					}

					if(side.left || side.right) {
						this.vx *= -1;
						this.collisionTimer = this.collisionDelay;
						this.bounces++;
						this.angle = pi-this.angle;
					}
				}
			}

			class Tank {
				constructor(x, y, colors, isPlayer=false, maxBullets=5, maxMines=3, shootDelay=30, scale=TANKSCALE) {
					this.x = x;
				  	this.y = y;
					this.isPlayer = isPlayer;
					this.colors = colors;
					this.shootDelay = shootDelay;
					this.shootTimer = 0;
					this.scale = scale;
					this.length = 60*this.scale;
				  	this.width = 45*this.scale;
					this.l2 = this.length/2;
					this.w2 = this.width/2;
				  	this.aimAngle = 0;
				  	this.angle = 0;
					this.hasShot = false;
					this.hasLaidMine = false;
					this.bullets = 0;
					this.maxBullets = maxBullets;
					this.maxMines = maxMines;
					this.speed = 2;
					this.mines = 0;
					this.canShoot = true;
					this.corner1 = {x:0, y:0, hasCollided:false, isColliding:false};
					this.corner2 = {x:0, y:0, hasCollided:false, isColliding:false};
					this.corner3 = {x:0, y:0, hasCollided:false, isColliding:false};
					this.corner4 = {x:0, y:0, hasCollided:false, isColliding:false};
					this.corners = [];
					this.updateCorners();
					this.trailDelay = 10 * this.scale;
					this.trailTimer = 0;
					this.dead = false;
					this.lastTile = null;
					this.recalculatePathDelay = 50;
					this.recalculatePathTimer = 0;
					this.path = [];
					this.pathIndex = 0;
					this.pathAngle = 0;
					this.backing = false;
					this.backingDelay = 16;
					this.backingTimer = 0;

					if(!this.isPlayer) {
						this.aimAngle = -Math.atan2((this.y-PLAYERTANK.y),(PLAYERTANK.x-this.x));;
					}
				}

				update() {
					let newTile = getTileAtPosition({x:this.x, y:this.y});
					if(this.lastTile != newTile && newTile.tileType != "E"  && newTile.tileType != "H") {
						if(this.lastTile != null)
							this.lastTile.tileType = "_";
						newTile.tileType = (this.dead ? newTile.tileType : (this.isPlayer ? "P" : "E"));
						this.lastTile = newTile;
					}

					this.shootTimer--;

				    if(this.isPlayer) {
						this.aimAngle = -Math.atan2((this.y-mouse.y),(mouse.x-this.x));
						if(GAMEISPLAYING)
							this.playerMovement();
					} else {
						this.aimAngle = -Math.atan2((this.y-PLAYERTANK.y),(PLAYERTANK.x-this.x));
						if(GAMEISPLAYING)
							this.ai();
					}

					drawTank(this.x, this.y, this.angle, this.aimAngle, this.width, this.length, this.colors);
					if(DEBUG) {
						text(this.x, this.y-10, 15, "Bullets:" + this.bullets + "/" + this.maxBullets, COLORS.gray1);
						text(this.x, this.y+10, 15, "Mines:" + this.mines + "/" + this.maxMines, COLORS.gray1);
					}

					this.updateCorners();
					if(DEBUG) {
						for(let corner of this.corners) {
							circle(corner.x, corner.y, 5,(corner.isColliding ? "red" : "green"));
						}
					}
				}

				recalculatePath() {
					let newPath = AStar(getTileAtPosition({x:this.x, y:this.y}), PLAYERTANK.lastTile);
					this.path =  newPath || this.path;
					if(newPath) {
						this.pathIndex = this.path.length-1;
						let nextTile = this.path[this.pathIndex];
						if(nextTile)
							this.pathAngle = -Math.atan2((this.y-nextTile.y),(nextTile.x-this.x));

					}
					this.recalculatePathTimer = this.recalculatePathDelay;
				}

				ai() {
					let thisTile = getTileAtPosition({x:this.x, y:this.y});
					let nextTile = this.path[this.pathIndex];

					this.recalculatePathTimer--;
					if(this.recalculatePathTimer <= 0) {
						this.recalculatePath();
					}

					console.log("SHOOTTIMER: " + this.shootTimer);

					if(this.shootTimer <= 0) {
						console.log("BOOM????");
						if(this.pointInSight({x:PLAYERTANK.x,y:PLAYERTANK.y})) {
							console.log("BOOM!!");
							this.shoot();
						}
					}

					if(DEBUG && nextTile) {
						circle(nextTile.x, nextTile.y, 10, this.colors.gun);
					}

					if(nextTile != null) {
						if((thisTile.gridX == nextTile.gridX && thisTile.gridY == nextTile.gridY)) {
							if(this.pathIndex >= 1) {
								this.pathIndex--;
								nextTile = this.path[this.pathIndex];
								this.pathAngle = -Math.atan2((this.y-nextTile.y),(nextTile.x-this.x));
							}
						} else {
							if(this.corner1.isColliding || this.corner2.isColliding) {
								this.backing = true;
								this.backingTimer = this.backingDelay;
							} else if (!this.backing) {
								//if(sin(this.angle) <= sin(this.pathAngle) + 0.03 && sin(this.angle) >= sin(this.pathAngle) - 0.03) {
								this.x += cos(this.angle) * this.speed;
								this.y += sin(this.angle) * this.speed;
								this.trail();
							}

							this.angle = moveTowards(this.angle, this.pathAngle, 0.03);
						}

						if(this.backing) {
							this.pathAngle = -Math.atan2((this.y-nextTile.y),(nextTile.x-this.x));
							this.backingTimer--;
							this.angle = moveTowards(this.angle, this.pathAngle, 0.06);
							if(this.backingTimer <= 0) {
								this.backing = false;
								this.backingTimer = this.backingDelay;
							}

							this.x -= cos(this.angle) * this.speed/2;
							this.y -= sin(this.angle) * this.speed/2;
						}

					}

					if(DEBUG) {
						for(let tile of this.path) {
							circle(tile.x, tile.y, 4, this.colors.body);
						}
					}

				}

				pointInSight(position) {
					if(PLAYERTANK.dead) {
						return false;
					}

					let currentCoords = getTileMapCoordsAtPosition({x:this.x, y:this.y});
					let playerCoords = getTileMapCoordsAtPosition({x:position.x, y:position.y});

					let dist = distance(currentCoords, playerCoords);

					let dx = -(currentCoords.x - playerCoords.x) / dist;
					let dy = -(currentCoords.y - playerCoords.y) / dist;
					let currentTile = "_";

					if(dist <= 1) {
						return true
					}

					while(currentTile == "_" || currentTile == "H") {
						if(DEBUG) {
							circle(currentCoords.x*currentLevel.tileWidth + currentLevel.tileWidth/2, currentCoords.y*currentLevel.tileHeight + currentLevel.tileHeight/2, 6, "yellow");
						}

						currentCoords.x += dx;
						currentCoords.y += dy;

						let rx = Math.round(currentCoords.x);
						let ry = Math.round(currentCoords.y);

						if(rx == Math.round(playerCoords.x) && ry == Math.round(playerCoords.y)) {
							return true;
						}

						currentTile = currentLevel.tileMap[ry][rx].tileType;
					}

					return false;
				}

				playerMovement() {
					let turnSpeed = 0.03;

					if((keyboard.up || keyboard.w) && !(this.corner1.isColliding || this.corner2.isColliding)) {
				      	this.x += cos(this.angle) * this.speed;
				      	this.y += sin(this.angle) * this.speed;
						this.trail();
					} else if((keyboard.down || keyboard.s) && !(this.corner3.isColliding || this.corner4.isColliding)) {
				      	this.x -= cos(this.angle) * this.speed;
				      	this.y -= sin(this.angle) * this.speed;
						this.trail();
				    }

					if(keyboard.space && !this.hasLaidMine && this.mines < this.maxMines) {
						mines.push(new Mine(this, this.x, this.y, 400));
						this.mines++;
						this.hasLaidMine = true;
				    } else if(!keyboard.space) {
					    this.hasLaidMine = false;
				    }

					if(keyboard.right || keyboard.d) {
						this.angle = moveTowards(this.angle, this.angle + turnSpeed*2, turnSpeed);
					} else if(keyboard.left || keyboard.a) {
						this.angle = moveTowards(this.angle, this.angle - turnSpeed*2, turnSpeed);
					}

					if(mouse.left) {
						if(this.hasShot) {
							if(this.shootTimer <= 0) {
								this.shoot();
							}
						} else {
							this.shoot();
						}
					} else if(!mouse.left) {
						this.hasShot = false;
					}
				}

				trail() {
					this.trailTimer--;
					if(this.trailTimer <= 0) {
						trails.push(new Trail(this.x, this.y, this.angle, this.width*0.8));
						this.trailTimer = this.trailDelay;
					}
				}

				updateCorners() {
					let c = cos(this.angle)*0.9;
					let s = sin(this.angle)*0.9;

					let lc = this.l2*c;
					let ls = this.l2*s;
					let wc = this.w2*c;
					let ws = this.w2*s;

					this.corner1.x = this.x + lc + ws;
					this.corner1.y = this.y + ls - wc;

					this.corner2.x = this.x + lc - ws;
					this.corner2.y = this.y + ls + wc;

					this.corner3.x = this.x - lc - ws;
					this.corner3.y = this.y - ls + wc;

					this.corner4.x = this.x - lc + ws;
					this.corner4.y = this.y - ls - wc;

					this.corners = [this.corner1, this.corner2, this.corner3, this.corner4];
				}

				shoot() {
					if(this.bullets < this.maxBullets) {
						bullets.push(new Bullet(this, this.x+cos(this.aimAngle)*this.length/1.3, this.y+sin(this.aimAngle)*this.length/1.3, this.aimAngle, PLAYERTANK.speed*1.2, 1));
						this.bullets++;
						this.shootTimer = this.shootDelay;
						this.hasShot = true;
					}
				}

				explode() {
					let radius = this.scale*50;
					if(!this.dead)
						explosions.push(new Explosion(this.x, this.y, radius, false, false, 13));

					this.die();
				}

				die() {
					tanks.splice(tanks.indexOf(this), 1);
					deadTanks.push(this);
					this.dead = true;

					let newTile = getTileAtPosition({x:this.x, y:this.y});
					newTile.tileType = "_";
				}

				deadUpdate() {
					this.drawMarker();
				}

				drawMarker() {
					save();
					translate(this.x, this.y);
					rotateRadians(this.angle-pi/2);
					cRectangle(0, 0, this.width, this.width/5, COLORS.white);
					rotateRadians(2*pi/4);
					cRectangle(0, 0, this.width, this.width/5, COLORS.white);
					restore();
				}

				isInsideCorners(point) {
					return !(this.isLeft(this.corner1, this.corner2, point) &&
							this.isLeft(this.corner2, this.corner3, point) &&
							this.isLeft(this.corner3, this.corner4, point) &&
							this.isLeft(this.corner4, this.corner1, point));
				}

				isLeft(P0, P1, P2) {
					 return ((P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y));
				}
			}


			class Tile {
				constructor(gridX, gridY, x, y, w, h, tileType, neighbours=null) {
					this.x = x;
					this.y = y;
					this.gridX = gridX;
					this.gridY = gridY;
					this.width = w;
					this.height = h;
					this.tileType = tileType;
					this.neighbours = neighbours;
					this.color = this.tileTypeToColor();
					this.halfWidth = this.width/2;
					this.halfHeight = this.height/2;
					this.cornerX = x - this.halfWidth;
					this.cornerY = y - this.halfHeight;
					this.destroyable = (tileType == tileType.toLowerCase());
					this.destroyed = false;
					this.timer = 30;
					this.neighbouringTiles = {up: null, down:null, left:null, right:null};

					//A*
					this.previous = null;
					this.f = 0;
					this.g = 0;
					this.h = 0;
				}

				tileTypeToColor(tileType=this.tileType) {
					switch(tileType) {
						default:
						case "B":
							return COLORS.sand4;
							break;
						case "b":
							return COLORS.sand1;
							break;
						case "H":
							return COLORS.gray2;
							break;
					}
				}

				destroy() {
					if(this.destroyable) {
						this.destroyed = true;
						this.tileType = "_";
					}
				}

				pointCollides(position) {
					if(this.destroyed)
						return false;

					let collides = false;

					if(this.tileType.toUpperCase() == "H") {
						collides = (distance(position, this) < this.width/2.3)
						return collides;
					}

					collides = (position.x >= this.cornerX && position.x <= this.cornerX + this.width && position.y >= this.cornerY && position.y <= this.cornerY + this.height);
					return collides;
				}

				getSideOfCollision(position) {
					let side = {up:false, down:false, left:false, right:false};

					let collisionBoxWidth = this.halfWidth/6;

					if(DEBUG) {
						cRectangle(this.x, this.y, collisionBoxWidth*2, collisionBoxWidth*2, COLORS.green1);
					}

					if(!this.neighbours.up && position.x >= this.cornerX && position.x <= this.cornerX + this.width && position.y >= this.cornerY && position.y <= this.cornerY + collisionBoxWidth) {
						side.up = true;
					} else if(!this.neighbours.down && position.x >= this.cornerX && position.x <= this.cornerX + this.width && position.y >= this.cornerY+this.height-collisionBoxWidth && position.y <= this.cornerY + this.height) {
						side.down = true;
					} else if(!this.neighbours.left && position.x >= this.cornerX && position.x <= this.cornerX + collisionBoxWidth && position.y >= this.cornerY && position.y <= this.cornerY + this.height) {
						side.left = true;
					} else if(!this.neighbours.right && position.x >= this.cornerX + this.width - collisionBoxWidth && position.x <= this.cornerX + this.width && position.y >= this.cornerY && position.y <= this.cornerY + this.height) {
						side.right = true;
					}

					return side;
				}

				update() {
					this.draw();
				}

				draw(tileType=this.tileType) {
					if(this.destroyed) {

					} else {
						switch(tileType) {
							default:
								cRectangle(this.x, this.y, this.width, this.height, this.color);
								break;
							case "H":
								circle(this.x, this.y, this.width/3, COLORS.gray2);
								circle(this.x, this.y, this.width/4, COLORS.gray1);
								break;
						}
						if(DEBUG) {
							circle(this.x, this.y, 5, COLORS.gray0);
							if(this.neighbours.up) {
								line(this.x, this.y, this.x, this.y-this.halfHeight/2, 2, COLORS.gray0);
								circle(this.x, this.y-this.halfHeight/2, 3, COLORS.gray0);
							}
							if(this.neighbours.down) {
								line(this.x, this.y, this.x, this.y+this.halfHeight/2, 2, COLORS.gray0);
								circle(this.x, this.y+this.halfHeight/2, 3, COLORS.gray0);
							}
							if(this.neighbours.left) {
								line(this.x, this.y, this.x-this.halfWidth/2, this.y, 2, COLORS.gray0);
								circle(this.x-this.halfWidth/2, this.y, 3, COLORS.gray0);
							}
							if(this.neighbours.right) {
								line(this.x, this.y, this.x+this.halfWidth/2, this.y, 2, COLORS.gray0);
								circle(this.x+this.halfWidth/2, this.y, 3, COLORS.gray0);
							}
						}
					}
				}
			}

			function drawTank(x, y, angle, aimAngle, width, length, colors, enemy=false) {
				save();
				translate(x, y);
				rotateRadians(angle);
				cRectangle(0, 0, length, width, colors.body);

				cRectangle(0, 0, width/3, width/1.5, colors.gun);
				cRectangle(0, width/3, length, width/8, colors.head);
				cRectangle(0, -width/3, length, width/8, colors.head);

				rotateRadians(aimAngle-angle);
				cRectangle(0, 0, width/2, width/2, colors.head);
				cRectangle(length/2.12, 0, length/1.6, width/7, colors.gun);
				cRectangle(length/1.3, 0, width/4, width/4, colors.gun);
				restore();
			}

			function moveTowards(current, target, maxDelta) {
				if(Math.abs(target - current) <= maxDelta) {
					return target;
				}
				return current + Math.sign(target - current) * maxDelta * getTurnDirection(current, target);
			}

			function getTurnDirection(current, target) {
				let diff =(target - current)%(2*pi);
				return(Math.abs(diff) > pi ? -1 : 1);
			}

			function cRectangle(x, y, w, h, color) {
				rectangle(x-w/2, y-h/2, w, h, color);
			}

			function tankColors(bodyc, headc, gunc) {
				return {
					body:bodyc,
					head:headc,
					gun:gunc
				};
			}

			const COLORS = {
				red1:"rgba(200, 10, 50, 1)",
				brown1:"rgba(137, 95, 67, 1)",
				brown2:"rgba(171, 119, 84, 1)",
				brown3:"rgba(179, 132, 101, 1)",
				green1:"rgba(70, 156, 48, 1)",
				green2:"rgba(78, 176, 54, 1)",
				green3:"rgba(104, 201, 79, 1)",
				orange1:"rgba(211, 84, 0, 1)",
				orange2:"rgba(230, 126, 34, 1)",
				orange3:"rgba(243, 156, 18, 1)",
				yellow1:"rgba(255, 212, 28, 1)",
				sand1:"rgba(227, 185, 130, 1)",
				sand2:"rgba(236, 204, 162, 1)",
				sand3:"rgba(231, 196, 150, 1)",
				sand4:"rgba(225, 191, 146, 1)",
				gray0:"rgba(85, 85, 85, 0.4)",
				gray1:"rgba(55, 55, 55, 1)",
				gray2:"rgba(85, 85, 85, 1)",
				gray3:"rgba(200, 200, 200, 1)",
				white:"rgba(230, 230, 230, 1)",
				startcolor:"rgba(40, 40, 40, 0.4)"
			};

			const DEBUGMAP = {
				name:"Debugging",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B_____BBbbBB______0_B",
					"B_____b__P_____B____B",
					"B__0__b________B____B",
					"B_____B________BBB__B",
				/*M*/"B________B__________B",
					"B____BBBBB__________B",
					"B____B______________B",
					"B____B_________0____B",
					"B_________0_________B",
					"B___________________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP1 = {
				name:"It Begins",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B___________________B",
					"B_____B___B___B_____B",
					"B_____B___B___H_____B",
					"B_________b___B_____B",
				/*M*/"B___P_____b___b__0__B",
					"B_________b___B_____B",
					"B_____B___B___H_____B",
					"B_____B___B___B_____B",
					"B___________________B",
					"B___________________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			const MAP2 = {
				name:"Walls",
				map:[
				    /*__________M_________*/
					"BBBBBBBBBBBBBBBBBBBBB",
					"B___________________B",
					"B_________________0_B",
					"B______________B____B",
					"B______________B____B",
					"B______________BBB__B",
				/*M*/"B___________________B",
					"B__BBB______________B",
					"B____B______________B",
					"B____B______________B",
					"B_P_________________B",
					"B___________________B",
					"BBBBBBBBBBBBBBBBBBBBB",
				]
			};

			function heuristic(tile, goal) {
				//return Math.abs(tile.x-goal.x) + Math.abs(tile.y-goal.y);
				//return(tile.x-goal.x)*(tile.y-goal.y);
				return distance(tile, goal);
			}

			function AStarPath(current, start, l=30) {
				let path = [];
				let temp = current;
				for(let i = 0; i < l; i++) {

					if(temp.previous == null) {
						break;
					}

					if(temp != start)
						path.push({x:temp.previous.x, y:temp.previous.y, gridX:temp.previous.gridX, gridY:temp.previous.gridY});

					temp = temp.previous;
				}
				return path;
			}

			function AStar(start=currentLevel.tileMap[1][1], goal=currentLevel.tileMap[currentLevel.height-1][currentLevel.width-1]) {
				let closedSet = [];
				let openSet = [start];

				for(let tile of currentLevel.tileMap) {
					tile.f = 0;
					tile.g = 0;
					tile.h = 0;
					tile.previous = null;
				}

				start.f = heuristic(start, goal);

				let i = 0;
				while(openSet.length > 0 && i < currentLevel.height*currentLevel.width*2) {
					i++;

					let nodeWithLowest = start;

					for(let open of openSet) {
						if(open.f < nodeWithLowest.f) {
							nodeWithLowest = open;
						}
					}

					let current = nodeWithLowest;

					if(current.gridX == goal.gridX && current.gridY == goal.gridY) {
						return AStarPath(current, start, i);
					}

					openSet.splice(openSet.indexOf(current), 1);
					closedSet.push(current);

					for(let key in current.neighbouringTiles) {
						let neighbouringTile = current.neighbouringTiles[key];
						if (neighbouringTile != null && neighbouringTile.tileType != "E" && (neighbouringTile.tileType == "_" || neighbouringTile.tileType == "P")) {

							if(closedSet.includes(neighbouringTile)) {
								continue;
							}

							let tentativeGScore = current.g + 1;

							if(!openSet.includes(neighbouringTile)) {
								openSet.push(neighbouringTile);
							} else if(tentativeGScore > neighbouringTile.g) {
								continue;
							}

							neighbouringTile.previous = current;
							neighbouringTile.g = tentativeGScore;
							neighbouringTile.h = heuristic(neighbouringTile, goal);
							neighbouringTile.f = neighbouringTile.g + neighbouringTile.h;
						}
					}
				}

				// no solution
				// console.log("It is impossible to complete the path. : " + i);
				return;
			}

			function printCurrentLevel() {
				let text = "\n";

				for(let y = 0; y < currentLevel.height; y++) {
					for(let x = 0; x < currentLevel.width; x++) {
						text += currentLevel.tileMap[y][x].tileType;
					}
					text += "\n";
				}
				text += "\n";

				console.log(text);
			}

			function createLevel(MAP) {
				let level = {
					name:MAP.name,
					height:MAP.map.length,
					width:MAP.map[0].length,
					tileWidth:totalWidth/MAP.map[0].length,
					tileHeight:totalHeight/MAP.map.length,
					map:MAP.map,
					tileMap:[],
					tiles:[],
					destroyableTiles:[],
					holes:[],
					playerSpawnpoint:{x:0,y:0},
					tanks:[],
				};

				level.tileMap = new Array(level.height);

				for(let y = 0; y < level.height; y++) {
					level.tileMap[y] = new Array(level.width);
				}

				for(let x = 0; x < level.width; x++) {
					for(let y = 0; y < level.height; y++) {
						let tileType = level.map[y][x];

						let tileNeighbours;
						let newTile = new Tile(x, y, level.tileWidth/2 + x*level.tileWidth, level.tileHeight/2 + y*level.tileHeight, level.tileWidth, level.tileHeight, tileType);

						let neighbours = {up:false, down:false, left:false, right:false};

						neighbours.left = (x-1 < 0) || (level.map[y][x-1] == "B");
						neighbours.right = (x+1 >= level.width) || (level.map[y][x+1] == "B");
						neighbours.up = (y-1 < 0) || (level.map[y-1][x] == "B");
						neighbours.down = (y+1 >= level.height) || (level.map[y+1][x] == "B");

						newTile.neighbours = neighbours;

						level.tileMap[y][x] = (newTile);

						if(tileType != "_") {
							if(tileType.toUpperCase() == "P") {
								level.playerSpawnpoint.x = newTile.x;
								level.playerSpawnpoint.y = newTile.y;
						    } else if(tileType.toUpperCase() == "H") {
							    level.holes.push(newTile);
							    level.tiles.push(newTile);
						    } else if (tileType == "0" || tileType == "1") {
							    // constructor(x, y, colors, isPlayer=false, maxBullets=5, maxMines=3, shootDelay=30, scale=TANKSCALE)
								level.tanks.push(new Tank(newTile.x, newTile.y, enemyTankColors[tileType], false, 1, 0, 50));
							} else {
								if(newTile.destroyable) {
									level.destroyableTiles.push(newTile);
								}
								level.tiles.push(newTile);
						     }
						}
					}
				}

				for(let x = 0; x < level.width; x++) {
					for(let y = 0; y < level.height; y++) {
						let neighbouringTiles = level.tileMap[y][x].neighbouringTiles;

						neighbouringTiles.left = (x-1 < 0 ? null : level.tileMap[y][x-1]);
						neighbouringTiles.right = (x+1 >= level.width ? null : level.tileMap[y][x+1]);
						neighbouringTiles.up = (y-1 < 0 ? null : level.tileMap[y-1][x]);
						neighbouringTiles.down = (y+1 >= level.height ? null : level.tileMap[y+1][x]);

						level.tileMap[y][x].neighbouringTiles = neighbouringTiles;
					}
				}

				return level;
			}

			function getTileMapCoordsAtPosition(position) {
				let x = Math.round(0.5 + position.x/currentLevel.tileWidth)-1;
				let y = Math.round(0.5 + position.y/currentLevel.tileHeight)-1;

				return {x:x, y:y};
			}

			function getTileAtPosition(position) {
				let coords = getTileMapCoordsAtPosition(position);

				let tile = currentLevel.tileMap[coords.y][coords.x];

				if(DEBUG) {
					cRectangle(currentLevel.tileWidth/2 + coords.x*currentLevel.tileWidth, currentLevel.tileHeight/2 + coords.y*currentLevel.tileHeight, currentLevel.tileWidth, currentLevel.tileHeight, COLORS.gray0);
				}

				return tile;
			}

			function graphicsAndCollisions() {
				fill(COLORS.sand2);

				for(let hole of currentLevel.holes) {
					hole.update();
				}

				for(let trail of trails) {
					trail.update();
				}

				for(let deadTank of deadTanks) {
					deadTank.deadUpdate();
					if(deadTank.isPlayer && !hasWon) {
						died = true;
					}
				}

				for(let bullet of bullets) {

					bullet.update();

					for(let mine of mines) {
						if((bullet.x - mine.x)*(bullet.x - mine.x) + (bullet.y - mine.y)*(bullet.y-mine.y) < mine.size*mine.size) {
							bullet.die();
							mine.explode();
						}
					}
				}

				for(let mine of mines) {
					mine.update();
				}

				for(let tank of tanks) {
					for(let corner of tank.corners) {
						corner.isColliding = corner.hasCollided;
						corner.hasCollided = false;
					}

					tank.update();
				}

				for(let explosion of explosions) {
					explosion.update();
				}

				for(let tile of currentLevel.tiles) {
					if(tile.tileType.toUpperCase() != "H")
						tile.update();

					for(let tank of tanks) {
						if((tank.x - tile.x)*(tank.x - tile.x) + (tank.y - tile.y)*(tank.y-tile.y) < 25000) {
							for(let corner of tank.corners) {
								if(!corner.hasCollided) {
									corner.hasCollided = tile.pointCollides(corner);
								}
							}
						}
					}

					for(let bullet of bullets) {
						if(bullet.collisionTimer <= 0 && !tile.destroyed && tile.tileType.toUpperCase() != "H") {
							if((bullet.x - tile.x)*(bullet.x - tile.x) + (bullet.y - tile.y)*(bullet.y - tile.y) < 90*90) {
								bullet.collide(tile.getSideOfCollision(bullet));
							}
						}

						for(let bullet2 of bullets) {
							if(bullet2 != bullet) {
								let sqrDistance = (bullet2.x - bullet.x)*(bullet2.x - bullet.x) + (bullet2.y - bullet.y)*(bullet2.y-bullet.y)
								let r = (TANKSCALE*TANKSCALE)*6.5*2;

								if(sqrDistance < r) {
									bullet.explode();
									bullet2.explode();
								}
							}
						}

						for(let tank of tanks) {

							let radius = TANKSCALE*27;
							let sqrDistance = (tank.x - bullet.x)*(tank.x - bullet.x) + (tank.y - bullet.y)*(tank.y-bullet.y);

							if(sqrDistance < radius*radius) {
								bullet.explode();
								tank.explode();
							}
						}
					}
				}
			}

			var DEBUG = true;

			canvas.getContext("2d").textAlign = "center";;

			const TANKCOLORS1 = tankColors(COLORS.orange1, COLORS.orange2, COLORS.orange3);
			const TANKCOLORS2 = tankColors(COLORS.brown1, COLORS.brown2, COLORS.brown3);
			const TANKCOLORS3 = tankColors(COLORS.green1, COLORS.green2, COLORS.green3);
			const TANKSCALE = totalHeight/700;
			const STARTDELAY = 180;
			const WINDELAY = 150;
			let startTimer = STARTDELAY;
			let winTimer = WINDELAY;
			var backgroundMusic = new Audio("http://66.90.93.122/ost/wii-play/qqvrntybtr/053%20-%20Tanks%20-%20Variation%201.mp3");
			var winMusic = new Audio("http://66.90.93.122/ost/wii-play/howmzfluwp/055%20-%20Tanks%20-%20Round%20End.mp3");

			var PLAYERTANK = new Tank(0, 0, TANKCOLORS3, true);

			var enemyTankColors = [
				TANKCOLORS2,
				TANKCOLORS1,
			];

			var GAMEISPLAYING = false;
			var START = false;
			var HASINITIATEDLEVEL = false;
			var HASSTARTEDONCE = false;

			var MAPS = [
				MAP1,
				MAP2,
			];

			var LEVELS = [];
			setLevels();

			function setLevels() {
				for(let MAP of MAPS) {
					LEVELS.push(createLevel(MAP));
				}
			}

			function resetLevel(id) {
				LEVELS[id] = createLevel(MAPS[id]);
			}

			let currentLevelId = 0;
			var currentLevel = LEVELS[currentLevelId];
			var hasWon = false;

			let hasPlayedMusic = false;
			let tanks = [];
			let deadTanks = [];
			let bullets = [];
			let mines = [];
			let explosions = [];

			let trails = [];
			let died = false;

			function win() {
				stopUpdate();
			}

			function restart() {
				resetLevel(currentLevelId);
				currentLevelId--;
				nextLevel();
			}

			function nextLevel() {
				GAMEISPLAYING = false;
				HASINITIATEDLEVEL = false;
				hasPlayedMusic = false;
				backgroundMusic.pause();
				backgroundMusic.currentTime = 0;
				winMusic.pause();
				winMusic.currentTime = 0;

				if(currentLevelId != LEVELS.length - 1) {
					currentLevelId++;
				} else {
					win();
				}

				PLAYERTANK.angle = 0;
				PLAYERTANK.trails = [];
				PLAYERTANK.bullets = 0;
				PLAYERTANK.mines = 0;
				bullets = [];
				mines = [];
				deadTanks = [];
				trails = [];

				currentLevel = LEVELS[currentLevelId];
				startTimer = STARTDELAY;
				winTimer = WINDELAY;
				hasWon = false;
				died = false;
			}

			function update() {
				if(!HASINITIATEDLEVEL) {
					START = (DEBUG || HASSTARTEDONCE);
					PLAYERTANK.x = currentLevel.playerSpawnpoint.x;
					PLAYERTANK.y = currentLevel.playerSpawnpoint.y;
					currentLevel.tanks.push(PLAYERTANK);
					tanks = currentLevel.tanks;
					HASINITIATEDLEVEL = true;
				}

				if(START) {
					GAMEISPLAYING = (startTimer <= 0);

					graphicsAndCollisions();

					if(!hasPlayedMusic) {
						backgroundMusic.pause();
						backgroundMusic.play();
						hasPlayedMusic = true;
					}

					if(!GAMEISPLAYING) {
						startTimer -= 0.8;
						circle(totalWidth/2, totalHeight/2, (startTimer*startTimer)*10, COLORS.startcolor);
						text(totalWidth/2, totalHeight/2, 120 - currentLevel.name.length*3, currentLevel.name, COLORS.white);
						text(totalWidth/2, totalHeight/2 + 80, 50, "Mission: " + (currentLevelId + 1), COLORS.white);
						text(totalWidth/2, totalHeight/2 + 160, 50, "Tanks: " + (tanks.length - 1), COLORS.white);
					} else {
						let info =  "Mission: " + (currentLevelId + 1) + " – " + currentLevel.name;
						text(totalWidth/2, totalHeight-currentLevel.tileHeight/4, currentLevel.tileHeight/2, info, COLORS.white);
						if(tanks.length <= 1) {
							if(tanks[0] == PLAYERTANK) {
								hasWon = true;
							}
						}

						if(hasWon || died) {
							winTimer -= 0.8;
							backgroundMusic.pause();
							winMusic.loop = false;
							if(!winMusic.ended) {
								winMusic.play();
							}

							let t = WINDELAY*WINDELAY*0.2-(winTimer*winTimer)*0.2;
							circle(totalWidth/2, totalHeight/2, t, COLORS.startcolor);
							if(winTimer <= 0) {
								if(hasWon) {
									nextLevel();
								} else {
									restart();
								}
							}
						}
					}
				} else {
					clearScreen();
					circle(totalWidth/2, totalHeight/2, 130, COLORS.red1);
					text(totalWidth/2, totalHeight/2, 15, "Click here to start!", COLORS.white);
					if(distance(totalWidth/2, totalHeight/2, mouse.x, mouse.y) < 130 && mouse.left) {
						START = true;
						HASSTARTEDONCE = true;
					}
				}
			}

		</script>
	</body>
</html>
